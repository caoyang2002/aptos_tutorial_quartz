---
title: 使用 move v2 和编译器 v2
---
参考

[Move 的未来（原文）](https://medium.com/aptoslabs/the-future-of-move-at-aptos-17d0656dcc31)
[[../杂文/The-Future-of-Move-at-Aptos]]

```bash
aptos move compile --compiler-version=2 --language-version=2
```

# Move在Aptos的未来

作者：Wolfgang Grieskamp

Move 是一种新颖的智能合约语言，被包括 Aptos 网络在内的几个区块链所使用。Move 是为 Meta的 Libra/Diem 区块链基于 **安全优先** 原则设计的，这使它成为市场上智能合约语言中最安全的语言。同时，这种方法导致了一个 **极简主义** 的语言，省略了许多高级语言特性，这些特性可以简化开发人员的工作。在 Aptos Labs，我们正在为 Move 开发一个新的编译器，即 **Aptos Move 编译器**，它带来了一套新的语言特性，填补了原始 Move 语言设计的空白，所有这些都不会影响安全性。在本文中，我们概述了一些最重要的即将推出的特性。这些特性中的许多还没有完全确定：我们提前预览分享，是为了在我们开始实现它们时征求社区的反馈。

==目录==
>- [接收者风格函数调用](#接收者风格函数调用) 
>- [一等高阶函数](#一等高阶函数)
>- [用户定义的权限](#用户定义的权限)
>- [资源访问控制](#资源访问控制)
>- [返回全局引用](#返回全局引用) 
>- [枚举类型和公共结构体](#枚举类型和公共结构体)
>- [规范语言](#规范语言)
>- [其他特性](#其他特性) 
>- [时间表和流程](#时间表和流程) 



# 接收者风格函数调用

接收者风格函数调用语法是一种众所周知的符号，其中调用的目标（“自身”）与函数名称和其余参数分开，如 `receiver.func(args)`。这种符号可以看作是 `func(receiver, args)` 的语法替代品。然而，这种符号的便利性还有更多：

- 函数 `func` 不需要显式导入或由定义模块限定名，因为接收者（第一个参数）的类型决定了它。
- 如果 `func` 的接收者参数是一个引用，编译器可以自动创建这个引用。例如，`func(&mut receiver, args)` 以接收者风格写成 `receiver.func(args)`。

Aptos Move编译器将实现这种符号。通过使用特定命名约定，如下面所示，可以启用它：

```rust
fun length<E>(self: &vector<E>)
```

在这里，`self` 不是一个关键字，而是对编译器的一个指示，表明这个函数可以被调用为 `vec.length()`。注意，这并不禁止当前的符号 `length(&vec)`，它仍然被支持，允许将现有代码升级到新符号而不需要破坏性更改。

有了接收者风格，可以允许受限的函数声明重载，只要它们通过接收者参数的类型来区分。因此，以下声明在一个模块中是允许的：

```rust
fun name(self: &T): String { self.name }
fun name(self: &R): String { self.other_name }
```

# 一等高阶函数

Aptos 在 2023 年初为 Move 添加的一个特性是对 **高阶函数** 和 **lambda** 的有限支持。例如，Move现在支持以下符号，它检查一个向量是否包含一个值大于零的元素（注意，我们假设是接收者风格，如上文讨论）：

```rust
vec.contains(|elem| elem > 0)
```

然而，当前对高阶函数的支持是有限的：只有 **内联函数** 可以作为参数接受函数，而且只有lambda表达式可以传递给这些函数参数。内联函数的一个严重限制是它们不能跨模块封装边界工作，这可能会诱使构建者牺牲模块封装。此外，使用太多的内联函数会导致代码大小增加，当部署代码时达到交易负载大小的限制。

Aptos Move编译器将支持一般的高阶函数，Move 虚拟机也将扩展以支持它们。实际上，不会发生语法变化，但高阶函数将不再仅限于内联函数。例如，我们可以编写如下代码（由于私有字段访问，今天不可能使用内联函数）：

```rust
struct State { val: u64 }

public fun transform(self: &mut State, f: |u64|u64) {
  s.val = f(s.val)
}
```

这个新特性有两个挑战：

- **可重入性**：一般的高阶函数打开了可重入攻击的问题。我们有一个解决方案通过[资源访问控制](https://medium.com/aptoslabs/the-future-of-move-at-aptos-17d0656dcc31#7a90)，如后文讨论。
- **闭包和引用**：闭包是捕获上下文变量的构造，这些变量是lambda引用的。例如，在 `let x = …; contains(vec, |elem| elem > x)` 中，`x` 就是这样一个上下文变量。如果需要捕获引用，这种捕获就变得困难。解决这个问题的方法是只允许捕获引用的闭包被传递到调用栈的*下方*。这确保了闭包的生命周期被封闭在捕获引用的生命周期内。

# 用户定义的权限

许多编程语言都有 **特性** （即，有界的参数多态性）的概念，允许将通用特性与类型关联起来，例如该类型的排序。这种多态性允许优雅的代码重用，例如编写适用于具有排序的任何类型的代码。在

Move中，我们已经有了相关的 **权限** 概念。这些权限限制在少数预定义用例中，如 `copy`、`key`、`store` 和 `drop` 权限。随着即将到来的 Aptos Move 编译器，我们计划扩展现有的 Move 权限系统，允许在语言中 **用户定义新的权限**。

权限可以如下声明，我们以迭代器权限为例。为了简单起见，我们描述的迭代器通过一个简单的API消耗它迭代的元素：

```rust
ability Iterator<E> {
  fun has_more(self: &Self): bool;
  fun next(self: &mut Self): E;
}
```

有了这样的权限，人们可以实现通用算法，这些算法适用于具有此权限的任何类型，例如搜索迭代器中匹配元素：

```rust
fun any<E, I: Iterator<E>>(iter: &mut I, predicate: |&E|bool): bool) {
  while (iter.has_more()) {
    if (predicate(&iter.next()) return true;
  }
  false
}
```

在上述代码中，`I: Iterator<E>` 意味着多态约束 `I` 只绑定到具有此权限的那些类型。

权限可以如下声明实现：

```rust
fun <E>Iterator<E>::has_more(self: &vector<E>): bool { !v.is_empty() }
fun <E>Iterator<E>::next(self: &mut vector<E>): E { self.pop().unwrap() }
```

我们也可以派生权限：

```rust
fun <E, I1: Iterator<E>, I2: Iterator<E>>
    Iterator<E>::next(self: &mut Chain<I1, I2>): E
{
  if (self.first().has_more())
    self.first_mut().next()
  else
    self.second_mut().next()
}
```

一些更多细节：

- **实现来源**：权限可以声明为**公共或非公共**。两种权限在任何地方都可见。然而，公共权限可以为在任何地方定义的类型*实现*，即使是在其他包中，而常规权限只能在定义类型的同一包中实现（孤儿规则）。注意，公共权限的可用性是实验性的，可能有助于为跨合约标准提供更多的灵活性。比较起来，它在Rust中不可用（但在Go中可用）。
- **实现唯一性**：在任何执行上下文中，对于给定类型只能有一个唯一的权限实现。这个实现必须由一个模块提供——可能在类型包之外。这两个要求在模块加载时检查。这意味着，即使类型检查器可能因为单独部署单元而没有发现它，模糊的实现也不可能在给定的执行上下文中重合或以某种方式被覆盖。这个属性避免了权限的语义混淆，同时也防止了通过权限的恶意攻击。
- **动态分派**：到目前为止描述的权限不启用动态分派，而是在编译时静态解析。与Rust相比，这是 `dyn T` 类型声明和常规 `T` 类型声明之间的区别。我们仍在讨论是否应该为权限支持动态分派。如果是这样，通过资源访问控制防止可重入性的工作将类似于高阶函数。

# 资源访问控制

资源访问控制([AIP-56](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-56.md)) 允许Move代码明确限制函数或交易可以访问的资源集。虽然这个特性在区块链执行和安全领域有应用，它也在语言层面上启用了各种场景，所以我们在这里简要描述它。

访问控制说明符是对Move中现有获取声明的概括。与 `fun f(..) acquires R` 不同，`R` 是某种资源类型（具有键权限的结构体），人们可以区分 `reads R `和 `writes R`。此外，可以使用通配符和否定。例如，`reads 0x42::*` 授予对给定地址声明的所有资源的读取访问，而 `!writes 0x42::*` *拒绝* 所有对此地址资源的写入访问。有关更多详细信息，请参见 [AIP-56](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-56.md)。

访问说明符和获取注释之间的一个主要区别是，前者是函数类型的一部分，可以全局可见，并且可以引用当前模块之外的资源。此外，访问说明符是动态评估的，允许它们被应用于没有明确提及它们的代码：执行具有特定访问限制的函数将把这个限制传递给从那个函数调用的所有代码。

访问说明符为跨信任边界的安全调用未知代码提供了解决方案——这些调用可能作为高阶函数或用户定义权限的结果发生。例如，考虑一个公共函数，它采用一个函数参数。通过函数类型，我们可以确保任何具体的参数都不会进行不必要的资源访问：

```
module myaddress::m {
  public fun do_some_work(…, callback: |u64| !write myaddress::*) …
}
```

在上述声明中，我们要求 `callback` 函数参数不要写入与给定模块声明相同的地址的任何资源，防止通过回调进行可重入攻击。

# 返回全局引用

目前，Move 不支持从常规函数调用返回对全局存储的引用。例如，我们**不能**编写以下代码：

```rust
fun access_resource(a: address): &Resource { 
  abort_if_access_invalid(a);
  borrow_global<Resource>(a) // 在这里出现引用安全错误
}
```

随着内联函数的引入，变得可能编写上述函数，但这些只能在定义资源类型的模块中使用。这个限制使得编写特定框架代码更加困难。例如，对于Aptos对象，通过返回引用的函数提供对对象的访问器将是自然的，而不是让用户代码去解析地址到引用。

这个限制的原因是，在当前Move中，返回的引用的来源不能被声明。然而，我们可以使用资源访问说明符作为一个指标来推导返回引用与全局存储的关系：

```
fun access_resource(a: address): &Resource
  reads Resource
{
  borrow_global<Resource>(a) // 由于访问声明而可以
}
```

更准确地说，这种解释的规则如下：

- 一个返回的引用，如果无法从任何输入引用的类型借用，则被视为全局引用。
- 每个全局引用必须有一个匹配的唯一访问说明符，用于资源类型，引用类型可以从中借用。

有了这些信息，扩展的引用安全分析可以维护Move的所有必要的内存安全条件。在Aptos实验室，我们正在正式化并实现这个新分析。

注意，这个启发式扩展了已经存在的处理返回引用的方法。目前，任何输出引用都被视为从任何输入引用借用的。这里描述的扩展处理涉及无法应用这个规则的情况。是否启发式足够还有待观察。技术上，这与Rust中的生命周期标签注释相差不远，但虽然合理，那些可能难以使用，所以我们目前尝试在Move语言中避免它们。

# 枚举类型和公共结构体

在Rust语言中找到的枚举类型是定义数据变体的强大特性。对于新的Aptos Move编译器，我们计划添加对枚举的完整支持。枚举声明如下：

```
public enum Option<A> has copy, drop, store {
  None,
  Some(A)
}
```

与Rust类似的匹配表达式将允许区分枚举：

```
match option {
  None => 0,
  Some(x) => x + 1
}
```

如上声明中所见，公共修饰符与枚举类型一起使用。一个公共枚举可以在定义它的模块之外进行匹配（否则，只允许局部匹配）。相同的公共修饰符也将对常规结构体可用，允许它们在模块之外被访问，并且也可以作为交易参数传递。还要注意枚举中位置字段的引入：这些也允许结构体（反过来，命名字段也允许枚举变体）。

有了枚举类型，我们将允许类型中的递归，这在Move中目前是不允许的。具有递归的枚举类型声明必须至少有一个非递归的终止变体，如下面的声明所示：

```
public enum List<A> has copy, drop, store {
   Nil,
   Cons{ hd: A, tl: List<A> }
}
```

枚举类型的一个常见应用是资源版本控制。例如，可以如下定义资源：

```
enum AccounData has key {
  V1 { <some fields> },
  V2 { <some fields>, <additional fields> }
  ... 任何未来的版本都可以放在这里 ...
}
```

这允许使用相同的存储插槽进行资源的新版本。像这样的应用程序需要处理匹配中缺少的变体。在编译时，编译器会因缺少变体而出错。然而，在运行时，字节码验证器允许那些缺失的匹配。只有当匹配被执行并且一个变体无法被处理时，执行才会中止。这允许在不阻止已经部署的旧代码的验证的情况下向枚举中添加变体。

# 规范语言

引入通用 **lambda** 和 **高阶函数** 也有助于解决规范和验证中的一个主要实际问题：处理循环不变式。有了高阶函数和能力，人们可以 *避免* 许多循环，而是使用 **filter-map-reduce** 模式。

证明者可以使用特殊的决策程序来处理 filter-map-reduce，而不是进入循环不变式的复杂性。下面是一个简单的例子：

```rust
let sum = reduce(&vec, 0, |a, e| a + e)
```

证明者可以通过结合 `reduce` 和 lambda 表达式体的知识，无需进一步帮助，验证这样的表达式。

对于更复杂的情况，lambda 表达式语法被扩展，以便能够附加前条件和后条件。例如，下面一个更复杂的函数用于 reduce 表达式中的聚合。同时，存在一个规范函数来模拟这种行为，所以我们可以用与 lambda 关联的规范块来指定这种关系：

```rust
reduce(&vec, N,
  |a, e|
  spec { // 指定lambda的结果
    ensures result == spec_aggregate(a, e);
  }
  aggregate(a, e)
)
```

# 其他特性

计划为 Move 添加多个较小的特性，以下是其中一些的列表：

- 有符号整数类型（`i8, i16, i32, i64, i128, i256`）
- 表示整数范围的类型，写成 `start..end`
- 向量索引的更直观语法（`v[index], v[start..end], &v[index], &mut v[index]`，以及类型 `[T]` 而不是 `vector<T>`）
- 对 `borrow_global<R>(addr)` 和 `borrow_global_mut<R>(addr)` 的更直观语法（与向量索引对齐，`R[addr]`，`&R[addr]` 和 `&mut R[addr]`）
- 新的循环语法：`for (var in exp) body.`。在这里，exp 可以是整数范围，或任何实现了 `Iterator` 或 `IntoIterator` 能力的东西。

# 时间表和流程

我们预计在 24 年上半年实现这些语言扩展的大部分。新的Aptos编译器将在 23 年底进入 beta 阶段，主要目标是与旧编译器功能对等。新特性将根据我们的用户——你们——以及应用程序的优先级逐步添加。我们将通过 Aptos 改进提案（AIPs）征求对语言特性的反馈，这将允许社区讨论和影响设计。Move 在 Aptos 有很多值得期待的东西，我们很高兴与你们一起将语言推向下一个级别！

#Move #Movelang #SmartContracts #FormalVerification



